%line 1+1 include/const.inc
SELECTOR_KERNEL_CS equ 1000b
SELECTOR_KERNEL_DS equ 10000b
LDT_SIZE equ 128

OFFSET_PROC_GS equ 0
OFFSET_PROC_FS equ OFFSET_PROC_GS + 4
OFFSET_PROC_ES equ OFFSET_PROC_FS + 4
OFFSET_PROC_DS equ OFFSET_PROC_ES + 4
OFFSET_PROC_EDI equ OFFSET_PROC_DS + 4
OFFSET_PROC_ESI equ OFFSET_PROC_EDI + 4
OFFSET_PROC_EBP equ OFFSET_PROC_ESI + 4
_OFFSET_PROC_ESP equ OFFSET_PROC_EBP + 4
OFFSET_PROC_EBX equ _OFFSET_PROC_ESP + 4
OFFSET_PROC_EDX equ OFFSET_PROC_EBX + 4
OFFSET_PROC_ECX equ OFFSET_PROC_EDX + 4
OFFSET_PROC_EAX equ OFFSET_PROC_ECX + 4
OFFSET_PROC_EIP equ OFFSET_PROC_EAX + 4
OFFSET_PROC_CS equ OFFSET_PROC_EIP + 4
OFFSET_PROC_EFLAGS equ OFFSET_PROC_CS + 4
OFFSET_PROC_ESP equ OFFSET_PROC_EFLAGS + 4
OFFSET_PROC_SS equ OFFSET_PROC_ESP + 4
OFFSET_PROC_PID equ OFFSET_PROC_SS + 4
OFFSET_PROC_TYPE equ OFFSET_PROC_PID + 4
OFFSET_PROC_LDT_SEL equ OFFSET_PROC_TYPE + 2
OFFSET_PROC_LDT equ OFFSET_PROC_LDT_SEL + 2
OFFSET_PROC_STACK equ OFFSET_PROC_LDT + 8 * LDT_SIZE

OFFSET_TSS_PREV equ 0
OFFSET_TSS_ESP0 equ OFFSET_TSS_PREV + 4

INT_M_CTL equ 0x20
INT_M_CTLMASK equ 0x21
INT_S_CTL equ 0xa0
INT_S_CTLMASK equ 0xa1
INT_EOI equ 0x20
%line 2+1 kernel/interrupt.asm

%line 10+1 kernel/interrupt.asm

%line 18+1 kernel/interrupt.asm

%line 83+1 kernel/interrupt.asm

[extern hw_irq_handler_table]
[extern current]
[extern sys_stacktop]
[extern tss]
[extern exception_handler]

[global divide_error]
[global single_step_exception]
[global nmi]
[global breakpoint_exception]
[global overflow]
[global bounds_check]
[global inval_opcode]
[global copr_not_available]
[global double_fault]
[global copr_seg_overrun]
[global inval_tss]
[global segment_not_present]
[global stack_exception]
[global general_protection]
[global page_fault]
[global copr_error]

[global hwint00]
[global hwint01]
[global hwint03]
[global hwint04]
[global hwint05]
[global hwint06]
[global hwint07]
[global hwint08]
[global hwint12]
[global hwint13]
[global hwint14]

[SECTION .text]
divide_error:
 push 0ffffffffh
 push 0
 jmp exception
single_step_exception:
 push 0ffffffffh
 push 1
 jmp exception
nmi:
 push 0ffffffffh
 push 2
 jmp exception
breakpoint_exception:
 push 0ffffffffh
 push 3
 jmp exception
overflow:
 push 0ffffffffh
 push 4
 jmp exception
bounds_check:
 push 0ffffffffh
 push 5
 jmp exception
inval_opcode:
 push 0ffffffffh
 push 6
 jmp exception
copr_not_available:
 push 0ffffffffh
 push 7
 jmp exception
double_fault:
 push 0ffffffffh
 push 8
 jmp exception
copr_seg_overrun:
 push 0ffffffffh
 push 9
 jmp exception
inval_tss:
 push 10
 jmp exception
segment_not_present:
 push 11
 jmp exception
stack_exception:
 push 12
 jmp exception
general_protection:
 push 13
 jmp exception
page_fault:
 push 14
 jmp exception
copr_error:
 push 0ffffffffh
 push 16
 jmp exception
exception:
 call exception_handler
 add esp, 4*2
 iret

hwint00:

%line 185+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 0)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 0)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 186+1 kernel/interrupt.asm

hwint01:

%line 188+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 1)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 1)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 189+1 kernel/interrupt.asm

hwint03:

%line 191+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 3)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 3)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 192+1 kernel/interrupt.asm

hwint04:

%line 194+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 4)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 4)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 195+1 kernel/interrupt.asm

hwint05:

%line 197+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 5)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 5)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 198+1 kernel/interrupt.asm

hwint06:

%line 200+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 6)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 6)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 201+1 kernel/interrupt.asm

hwint07:

%line 203+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_M_CTLMASK
 or al, (1 << 7)
 out INT_M_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*0]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_M_CTLMASK
 and al, ~(1 << 7)
 out INT_M_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 204+1 kernel/interrupt.asm

hwint08:

%line 206+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_S_CTLMASK
 or al, (1 << 0)
 out INT_S_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*1]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_S_CTLMASK
 and al, ~(1 << 0)
 out INT_S_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 207+1 kernel/interrupt.asm

hwint12:

%line 209+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_S_CTLMASK
 or al, (1 << 4)
 out INT_S_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*1]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_S_CTLMASK
 and al, ~(1 << 4)
 out INT_S_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 210+1 kernel/interrupt.asm

hwint13:

%line 212+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_S_CTLMASK
 or al, (1 << 5)
 out INT_S_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*1]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_S_CTLMASK
 and al, ~(1 << 5)
 out INT_S_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 213+1 kernel/interrupt.asm

hwint14:

%line 215+0 kernel/interrupt.asm
 pusha
 push ds
 push es
 push fs
 push gs
 mov ax, SELECTOR_KERNEL_DS
 mov ds, ax
 mov es, ax


 in al, INT_S_CTLMASK
 or al, (1 << 6)
 out INT_S_CTLMASK, al

 sti

 mov eax, [current]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .skip
 mov [eax+OFFSET_PROC_ESP], esp
 mov [eax+OFFSET_PROC_SS], ss
.skip:

 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
 mov esp, sys_stacktop

 call [hw_irq_handler_table + 4*1]

 mov eax, [current]
 lldt word [eax+OFFSET_PROC_LDT_SEL]
 cmp word [eax+OFFSET_PROC_TYPE], 0
 jne .user_proc
 mov ss, [eax+OFFSET_PROC_SS]
 mov esp, [eax+OFFSET_PROC_ESP]
 jmp .fini
.user_proc:
 lea ebx, [eax+OFFSET_PROC_PID]
 mov [tss+OFFSET_TSS_ESP0], ebx
 mov esp, eax
 mov ax, SELECTOR_KERNEL_DS
 mov ss, ax
.fini:

 in al, INT_S_CTLMASK
 and al, ~(1 << 6)
 out INT_S_CTLMASK, al

 mov al, INT_EOI
 out INT_M_CTL, al

 pop gs
 pop fs
 pop es
 pop ds
 popa
 iret
%line 216+1 kernel/interrupt.asm

